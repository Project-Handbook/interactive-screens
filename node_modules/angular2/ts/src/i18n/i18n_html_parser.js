System.register(['angular2/src/compiler/html_parser', 'angular2/src/compiler/html_ast', 'angular2/src/facade/collection', 'angular2/src/facade/lang', 'angular2/src/facade/exceptions', './message', './shared'], function(exports_1, context_1) {
    "use strict";
    var __moduleName = context_1 && context_1.id;
    var html_parser_1, html_ast_1, collection_1, lang_1, exceptions_1, message_1, shared_1;
    var _I18N_ATTR, _PLACEHOLDER_ELEMENT, _NAME_ATTR, _I18N_ATTR_PREFIX, _PLACEHOLDER_EXPANDED_REGEXP, I18nHtmlParser, _CreateNodeMapping;
    return {
        setters:[
            function (html_parser_1_1) {
                html_parser_1 = html_parser_1_1;
            },
            function (html_ast_1_1) {
                html_ast_1 = html_ast_1_1;
            },
            function (collection_1_1) {
                collection_1 = collection_1_1;
            },
            function (lang_1_1) {
                lang_1 = lang_1_1;
            },
            function (exceptions_1_1) {
                exceptions_1 = exceptions_1_1;
            },
            function (message_1_1) {
                message_1 = message_1_1;
            },
            function (shared_1_1) {
                shared_1 = shared_1_1;
            }],
        execute: function() {
            _I18N_ATTR = "i18n";
            _PLACEHOLDER_ELEMENT = "ph";
            _NAME_ATTR = "name";
            _I18N_ATTR_PREFIX = "i18n-";
            _PLACEHOLDER_EXPANDED_REGEXP = lang_1.RegExpWrapper.create("\\<ph(\\s)+name=(\"(\\d)+\")\\>\\<\\/ph\\>");
            /**
             * Creates an i18n-ed version of the parsed template.
             *
             * Algorithm:
             *
             * To understand the algorithm, you need to know how partitioning works.
             * Partitioning is required as we can use two i18n comments to group node siblings together.
             * That is why we cannot just use nodes.
             *
             * Partitioning transforms an array of HtmlAst into an array of Part.
             * A part can optionally contain a root element or a root text node. And it can also contain
             * children.
             * A part can contain i18n property, in which case it needs to be transalted.
             *
             * Example:
             *
             * The following array of nodes will be split into four parts:
             *
             * ```
             * <a>A</a>
             * <b i18n>B</b>
             * <!-- i18n -->
             * <c>C</c>
             * D
             * <!-- /i18n -->
             * E
             * ```
             *
             * Part 1 containing the a tag. It should not be translated.
             * Part 2 containing the b tag. It should be translated.
             * Part 3 containing the c tag and the D text node. It should be translated.
             * Part 4 containing the E text node. It should not be translated.
             *
             *
             * It is also important to understand how we stringify nodes to create a message.
             *
             * We walk the tree and replace every element node with a placeholder. We also replace
             * all expressions in interpolation with placeholders. We also insert a placeholder element
             * to wrap a text node containing interpolation.
             *
             * Example:
             *
             * The following tree:
             *
             * ```
             * <a>A{{I}}</a><b>B</b>
             * ```
             *
             * will be stringified into:
             * ```
             * <ph name="e0"><ph name="t1">A<ph name="0"/></ph></ph><ph name="e2">B</ph>
             * ```
             *
             * This is what the algorithm does:
             *
             * 1. Use the provided html parser to get the html AST of the template.
             * 2. Partition the root nodes, and process each part separately.
             * 3. If a part does not have the i18n attribute, recurse to process children and attributes.
             * 4. If a part has the i18n attribute, merge the translated i18n part with the original tree.
             *
             * This is how the merging works:
             *
             * 1. Use the stringify function to get the message id. Look up the message in the map.
             * 2. Get the translated message. At this point we have two trees: the original tree
             * and the translated tree, where all the elements are replaced with placeholders.
             * 3. Use the original tree to create a mapping Index:number -> HtmlAst.
             * 4. Walk the translated tree.
             * 5. If we encounter a placeholder element, get is name property.
             * 6. Get the type and the index of the node using the name property.
             * 7. If the type is 'e', which means element, then:
             *     - translate the attributes of the original element
             *     - recurse to merge the children
             *     - create a new element using the original element name, original position,
             *     and translated children and attributes
             * 8. If the type if 't', which means text, then:
             *     - get the list of expressions from the original node.
             *     - get the string version of the interpolation subtree
             *     - find all the placeholders in the translated message, and replace them with the
             *     corresponding original expressions
             */
            I18nHtmlParser = (function () {
                function I18nHtmlParser(_htmlParser, _parser, _messagesContent, _messages) {
                    this._htmlParser = _htmlParser;
                    this._parser = _parser;
                    this._messagesContent = _messagesContent;
                    this._messages = _messages;
                }
                I18nHtmlParser.prototype.parse = function (sourceContent, sourceUrl) {
                    this.errors = [];
                    var res = this._htmlParser.parse(sourceContent, sourceUrl);
                    if (res.errors.length > 0) {
                        return res;
                    }
                    else {
                        var nodes = this._recurse(res.rootNodes);
                        return this.errors.length > 0 ? new html_parser_1.HtmlParseTreeResult([], this.errors) :
                            new html_parser_1.HtmlParseTreeResult(nodes, []);
                    }
                };
                I18nHtmlParser.prototype._processI18nPart = function (p) {
                    try {
                        return p.hasI18n ? this._mergeI18Part(p) : this._recurseIntoI18nPart(p);
                    }
                    catch (e) {
                        if (e instanceof shared_1.I18nError) {
                            this.errors.push(e);
                            return [];
                        }
                        else {
                            throw e;
                        }
                    }
                };
                I18nHtmlParser.prototype._mergeI18Part = function (p) {
                    var messageId = message_1.id(p.createMessage(this._parser));
                    if (!collection_1.StringMapWrapper.contains(this._messages, messageId)) {
                        throw new shared_1.I18nError(p.sourceSpan, "Cannot find message for id '" + messageId + "'");
                    }
                    var parsedMessage = this._messages[messageId];
                    return this._mergeTrees(p, parsedMessage, p.children);
                };
                I18nHtmlParser.prototype._recurseIntoI18nPart = function (p) {
                    // we found an element without an i18n attribute
                    // we need to recurse in cause its children may have i18n set
                    // we also need to translate its attributes
                    if (lang_1.isPresent(p.rootElement)) {
                        var root = p.rootElement;
                        var children = this._recurse(p.children);
                        var attrs = this._i18nAttributes(root);
                        return [
                            new html_ast_1.HtmlElementAst(root.name, attrs, children, root.sourceSpan, root.startSourceSpan, root.endSourceSpan)
                        ];
                    }
                    else if (lang_1.isPresent(p.rootTextNode)) {
                        return [p.rootTextNode];
                    }
                    else {
                        return this._recurse(p.children);
                    }
                };
                I18nHtmlParser.prototype._recurse = function (nodes) {
                    var _this = this;
                    var ps = shared_1.partition(nodes, this.errors);
                    return collection_1.ListWrapper.flatten(ps.map(function (p) { return _this._processI18nPart(p); }));
                };
                I18nHtmlParser.prototype._mergeTrees = function (p, translated, original) {
                    var l = new _CreateNodeMapping();
                    html_ast_1.htmlVisitAll(l, original);
                    // merge the translated tree with the original tree.
                    // we do it by preserving the source code position of the original tree
                    var merged = this._mergeTreesHelper(translated, l.mapping);
                    // if the root element is present, we need to create a new root element with its attributes
                    // translated
                    if (lang_1.isPresent(p.rootElement)) {
                        var root = p.rootElement;
                        var attrs = this._i18nAttributes(root);
                        return [
                            new html_ast_1.HtmlElementAst(root.name, attrs, merged, root.sourceSpan, root.startSourceSpan, root.endSourceSpan)
                        ];
                    }
                    else if (lang_1.isPresent(p.rootTextNode)) {
                        throw new exceptions_1.BaseException("should not be reached");
                    }
                    else {
                        return merged;
                    }
                };
                I18nHtmlParser.prototype._mergeTreesHelper = function (translated, mapping) {
                    var _this = this;
                    return translated.map(function (t) {
                        if (t instanceof html_ast_1.HtmlElementAst) {
                            return _this._mergeElementOrInterpolation(t, translated, mapping);
                        }
                        else if (t instanceof html_ast_1.HtmlTextAst) {
                            return t;
                        }
                        else {
                            throw new exceptions_1.BaseException("should not be reached");
                        }
                    });
                };
                I18nHtmlParser.prototype._mergeElementOrInterpolation = function (t, translated, mapping) {
                    var name = this._getName(t);
                    var type = name[0];
                    var index = lang_1.NumberWrapper.parseInt(name.substring(1), 10);
                    var originalNode = mapping[index];
                    if (type == "t") {
                        return this._mergeTextInterpolation(t, originalNode);
                    }
                    else if (type == "e") {
                        return this._mergeElement(t, originalNode, mapping);
                    }
                    else {
                        throw new exceptions_1.BaseException("should not be reached");
                    }
                };
                I18nHtmlParser.prototype._getName = function (t) {
                    if (t.name != _PLACEHOLDER_ELEMENT) {
                        throw new shared_1.I18nError(t.sourceSpan, "Unexpected tag \"" + t.name + "\". Only \"" + _PLACEHOLDER_ELEMENT + "\" tags are allowed.");
                    }
                    var names = t.attrs.filter(function (a) { return a.name == _NAME_ATTR; });
                    if (names.length == 0) {
                        throw new shared_1.I18nError(t.sourceSpan, "Missing \"" + _NAME_ATTR + "\" attribute.");
                    }
                    return names[0].value;
                };
                I18nHtmlParser.prototype._mergeTextInterpolation = function (t, originalNode) {
                    var split = this._parser.splitInterpolation(originalNode.value, originalNode.sourceSpan.toString());
                    var exps = lang_1.isPresent(split) ? split.expressions : [];
                    var messageSubstring = this._messagesContent.substring(t.startSourceSpan.end.offset, t.endSourceSpan.start.offset);
                    var translated = this._replacePlaceholdersWithExpressions(messageSubstring, exps, originalNode.sourceSpan);
                    return new html_ast_1.HtmlTextAst(translated, originalNode.sourceSpan);
                };
                I18nHtmlParser.prototype._mergeElement = function (t, originalNode, mapping) {
                    var children = this._mergeTreesHelper(t.children, mapping);
                    return new html_ast_1.HtmlElementAst(originalNode.name, this._i18nAttributes(originalNode), children, originalNode.sourceSpan, originalNode.startSourceSpan, originalNode.endSourceSpan);
                };
                I18nHtmlParser.prototype._i18nAttributes = function (el) {
                    var _this = this;
                    var res = [];
                    el.attrs.forEach(function (attr) {
                        if (attr.name.startsWith(shared_1.I18N_ATTR_PREFIX) || attr.name == shared_1.I18N_ATTR)
                            return;
                        var i18ns = el.attrs.filter(function (a) { return a.name == "i18n-" + attr.name; });
                        if (i18ns.length == 0) {
                            res.push(attr);
                            return;
                        }
                        var i18n = i18ns[0];
                        var messageId = message_1.id(shared_1.messageFromAttribute(_this._parser, el, i18n));
                        if (collection_1.StringMapWrapper.contains(_this._messages, messageId)) {
                            var updatedMessage = _this._replaceInterpolationInAttr(attr, _this._messages[messageId]);
                            res.push(new html_ast_1.HtmlAttrAst(attr.name, updatedMessage, attr.sourceSpan));
                        }
                        else {
                            throw new shared_1.I18nError(attr.sourceSpan, "Cannot find message for id '" + messageId + "'");
                        }
                    });
                    return res;
                };
                I18nHtmlParser.prototype._replaceInterpolationInAttr = function (attr, msg) {
                    var split = this._parser.splitInterpolation(attr.value, attr.sourceSpan.toString());
                    var exps = lang_1.isPresent(split) ? split.expressions : [];
                    var first = msg[0];
                    var last = msg[msg.length - 1];
                    var start = first.sourceSpan.start.offset;
                    var end = last instanceof html_ast_1.HtmlElementAst ? last.endSourceSpan.end.offset : last.sourceSpan.end.offset;
                    var messageSubstring = this._messagesContent.substring(start, end);
                    return this._replacePlaceholdersWithExpressions(messageSubstring, exps, attr.sourceSpan);
                };
                ;
                I18nHtmlParser.prototype._replacePlaceholdersWithExpressions = function (message, exps, sourceSpan) {
                    var _this = this;
                    return lang_1.RegExpWrapper.replaceAll(_PLACEHOLDER_EXPANDED_REGEXP, message, function (match) {
                        var nameWithQuotes = match[2];
                        var name = nameWithQuotes.substring(1, nameWithQuotes.length - 1);
                        var index = lang_1.NumberWrapper.parseInt(name, 10);
                        return _this._convertIntoExpression(index, exps, sourceSpan);
                    });
                };
                I18nHtmlParser.prototype._convertIntoExpression = function (index, exps, sourceSpan) {
                    if (index >= 0 && index < exps.length) {
                        return "{{" + exps[index] + "}}";
                    }
                    else {
                        throw new shared_1.I18nError(sourceSpan, "Invalid interpolation index '" + index + "'");
                    }
                };
                return I18nHtmlParser;
            }());
            exports_1("I18nHtmlParser", I18nHtmlParser);
            _CreateNodeMapping = (function () {
                function _CreateNodeMapping() {
                    this.mapping = [];
                }
                _CreateNodeMapping.prototype.visitElement = function (ast, context) {
                    this.mapping.push(ast);
                    html_ast_1.htmlVisitAll(this, ast.children);
                    return null;
                };
                _CreateNodeMapping.prototype.visitAttr = function (ast, context) { return null; };
                _CreateNodeMapping.prototype.visitText = function (ast, context) {
                    this.mapping.push(ast);
                    return null;
                };
                _CreateNodeMapping.prototype.visitComment = function (ast, context) { return ""; };
                return _CreateNodeMapping;
            }());
        }
    }
});
//# sourceMappingURL=i18n_html_parser.js.map